---
layout: post
title:  "Game development"
date:   2025-08-31
date_modified: 2025-09-22
categories: post
publish: true
ongoing: true

ids:
    - Introduction
    - Optionals
    - Monads
    - Streams
# defs:
---

A story about childhood dreams, a love for software development and some funky mathematics. For the people who read my other posts on <a href = "{% post_url 2023-06-30-TypeTheory %}" target = "_blank">modal type theory</a> and <a href = "{% post_url 2025-01-19-TMR2 %}" target = "_blank">quantum logic</a>, this post will also contain type theory. &#128513;

<div class = "note">
    <div class = "side">Note</div>
    The beautiful typesetting of code snippets was made possible by <a href = "https://prismjs.com" target = "_blank" rel = "noopener">Prism</a>. For everyone who wants to add code to their website, this plugin has language support for basically every programming language out there, and even has dark mode themes. 
</div>

<hr id = "Introduction">
<div class = "nav-block"><div class = "side">Introduction</div></div>

<div class = "language-java" markdown = "1">
In my fifth year of high school, I had to choose between taking two hours of applied sciences or two hours of mathematics and programming on top of the regular mathematics and science curriculum. The programming part was about the basics of <tt>Java</tt> (through BlueJ[^1]). At that time, my father had already taught me some things about programming and had shown me some of the projects he had made in <tt>Delphi</tt> (a <tt>Pascal</tt> derivative). However, this was the real deal. It took a bit before I started enjoying it, but once I was able to play with it myself, I quickly learned how amazing programming was.<br><br>

My first project was developping a game. In the fifth year of primary school, during the last week of school, our teacher introduced us to the wonderful world of Age of Empires (AoE I to be specific). No wonder my first own game had to be something like Age of Empires: a real time strategy game. I started implementing unit and building classes, resource systems, graphics and an AI (clearly at that time this did not consist of much, but it worked!) I quickly got the support of two class mates and we worked on this project together for a while (adding multiplayer amongst other things). However, due to holiday breaks and, more importantly, at the end of the last year of high school, the change to university, this project fell apart.<br><br>

However, over the years, I often returned to this project. At some point, I tried to salvage the code I could recover from my high school days, but, sadly, this was to no avail. I had to (re)start from scratch. This blog post will cover my latest iteration, which covers a few years (be it with lengthy breaks). When I started learning <tt>Java</tt>, version (1.)7 was in use. At the time of writing, version (1.)24 was the latest one. Many things have changed and many improvements have been added to the language. This means that, after obtaining a PhD in statistics, which implies working with Python for 4 years (and more), I had to relearn a lot and also learned new things along the way. I selected a handful of topics that I want to cover in more detail, give my opinion about their use, and explain some relations to formal mathematics.

[^1]: What a nightmare.

<hr id = "Optionals">
<div class = "nav-block"><div class = "side">Optionals</div></div>

The following practice is common in <tt>Java</tt> code:

<pre><code>
    public void someMethod(ClassA obj) {
        if(obj != null)
            obj.doSomething();
    }
</code></pre>

Although this is very clear from the perspective of readability, it is slightly verbose, increase the amount of brackets that need to be inserted (for longer code blocks), etc. For example, assume that we want to perform a chain of operations. If we want to foolproof the following method call <code>obj.getSomeAttribute().doSomething()</code>,

we would have to write

<pre><code>
    public void someMethod(ClassA obj) {
        if(obj != null &amp;&amp; obj.getSomeAttribute() != null)
            obj.getSomeAttribute().doSomething();
    }
</code></pre>

which requires calling <code class = "language-java">getSomeAttribute()</code> twice, an approach that ought be avoided in general (especially for costly methods), or

<pre><code>
    public void someMethod(SomeClass obj) {
        if(obj != null) {
            ClassB attr = obj.getSomeAttribute();
            if(attr != null)
                attr.doSomething();
        }
    }
</code></pre>

The situation gets even worse if <code>null</code> values need to be handled. This introduces even more braces and control statements. Moreover, without inspection of a method's implementation, it is not clear a priori whether it can return <code>null</code> or not (except when its return type is <code>void</code>). Accordingly, in general, we would need to check for null every time we use a method that is not <code>void</code> or returns a primitive type.<br><br>

To this end, <tt>Java 8</tt> introduced a new (generic) <code>class</code>: <code>Optional&lt;T></code>. This new <code>class</code> solves both issues. When using a method whose return type is of the form, it is immediately clear that the value could correspond to <code>null</code> (of course, it should not exactly be null as this would defeat the whole purpose). The way <code>Optional&lt;T></code> is implemented also allows for easier program flow. The situation considered above will now look as follows:

<pre><code>
    public void someMethod(Optional&lt;SomeClass> obj) {
        obj.ifPresent(ClassA::getSomeAttribute).ifPresent(ClassB::doSomething);
    }
</code></pre>

As in the <code>Stream</code> API, methods can easily be chained. (We will come back to this in a <a href = "#Streams">section</a> further below.) Now, given an instance <code>Optional&lt;T> opt</code>, how do we handle <code>null</code> values? This is covered by the <code>forElse()</code> construction:[^2] The line <code>T result = opt.orElse(alternative);</code> will

* return the instance of <code>class T</code> contained by <code>opt</code> if it is not <code>null</code>, or
* return <code>alternative</code> otherwise.

[^2]: <code>ifPresent(Consumer&lt;? super T> consumer)</code> also admits an alternative <code>ifPresentOrElse(Consumer&lt;? super T> consumer, Runnable alternative)</code> since <tt>Java 9</tt>. 

<hr id = "Monads">
<div class = "nav-block"><div class = "side">Monads</div></div>

In the preceeding section, we saw how we can handle <code>null</code> values in a safe and controlled manner. The only piece that remains is how to instantiate <tt>Java</tt>'s <code>Optional&lt;T></code>'s. The most general method to obtain an <code>Optional&lt;T></code> reads as <code>Optional&lt;T> ofNullable(T obj)</code>. If <code>obj == null</code>, it will represent an "empty" <code>Optional&lt;T></code>. Let us introduce the notations "Nothing" and "Just obj", depending on whether <code>obj == null</code> or not.<br><br>

Combined with the functionality presented in the preceeding section, it follows that <tt>Java</tt>'s <code>Optional</code> API gives a common example of a <b>monad</b> (see my previous post on <a href = "{% post_url 2023-05-17-PictorialBayes%}#Monad" target = "_blank">diagrammatic calculus</a> for more information). In particular, it constitutes the <b>Maybe monad</b>. Formally, it is characterized by the following natural deduction rules:

* <b>Formation</b>: $A:\mathrm{Type}\vdash\mathrm{Maybe}\,A:\mathrm{Type}$,
* <b>Introduction</b>: $a:A\vdash\mathrm{Just}\,a:\mathrm{Maybe}\,A \mid \mathrm{Nothing}:\mathrm{Maybe}\,A$,
* <b>Elimination</b>: $o:\mathrm{Maybe}\,A,f:A\rightarrow B\vdash f(o):\mathrm{Maybe}\,B$,
* <b>Computation</b>:
    * $f(\mathrm{Nothing}) \equiv \mathrm{Nothing}$, and
    * $f(\mathrm{Just}\,a) \equiv \mathrm{Just}\,f(a)$.

Let us unpack these rules (in <tt>Java</tt>):
* The formation rule says that for every <code>class A</code>, there exists a <code>class Optional&lt;A></code>.
* The introduction rule says that there are two ways to obtain an instance of <code>Optional&lt;A></code>. Either by wrapping an instance of <code>A</code> or the empty <code>Optional&lt;A></code>.
* The elimination rule says that, if we have a method <code>public B f(A obj)</code>, we can map any <code>Optional&lt;A></code> to an <code>Optional&lt;B></code>, i.e. we obtain a method <code>public Optional&lt;B> f(Optional&lt;A> opt)</code>.[^3]
* The implementation of this elimination rule goes as follows:
    * If <code>obj == null</code>, we are working with $\mathrm{Nothing}$, and $\mathrm{Nothing}$ is always mapped to $\mathrm{Nothing}$. Once we start with <code>null</code>, it remains <code>null</code> until the end of time.
    * For nonnull objects, we are working with an instance of the form $\mathrm{Just}\,a$ and applying $f$ is straightforward. $\mathrm{Just}\,a$ is simply a wrapper of $a$, so we can unwrap it, apply $f$ and then wrap it again.

[^3]: Here, and in the preceeding section, I have given into some abuse of notation. Since the function induced by $f$ is not exactly equal to $f$, it should have been denoted by something like $\mathrm{Maybe}\,f$.

<hr id = "Streams">
<div class = "nav-block"><div class = "side">Streams</div></div>

<div style = "height: 300px"></div>

</div>

<hr id = "Footnotes">
<div class = "nav-block"><div class = "side">Footnotes</div></div>

