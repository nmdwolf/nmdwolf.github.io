---
layout: post
title:  "Game development"
date:   2025-08-31
date_modified: 2025-10-26
categories: post
publish: true
ongoing: true

ids:
    - Introduction
    - Optionals
    - Monads
    - Streams
    - References
defs:
    - Maybe
    - Carrier
    - Catamorphism
---

A story about childhood dreams, a love for software development and some funky mathematics. For the people who read my other posts on <a href = "{% post_url 2023-06-30-TypeTheory %}" target = "_blank">modal type theory</a> and <a href = "{% post_url 2025-01-19-TMR2 %}" target = "_blank">quantum logic</a>, this post will also contain type theory. &#128513;

<div class = "note">
    <div class = "side">Note</div>
    The beautiful typesetting of code snippets was made possible by <a href = "https://prismjs.com" target = "_blank" rel = "noopener">Prism</a>. For everyone who wants to add code to their website, this plugin has language support for basically every programming language out there, and even has dark mode themes. 
</div>

<hr id = "Introduction">
<div class = "nav-block"><div class = "side">Introduction</div></div>

<div class = "language-java" markdown = "1">
In my fifth year of high school, I had to choose between taking two hours of applied sciences or two hours of mathematics and programming on top of the regular mathematics and science curriculum. The programming part was about the basics of <tt>Java</tt> (through <a href = "https://www.bluej.org/" target = "_blank" rel = "noopener">BlueJ</a>[^1]). At that time, my father had already taught me some things about programming and had shown me some of the projects he had made in <tt>Delphi</tt> (a <tt>Pascal</tt> derivative). However, this was the real deal. It took a bit before I started enjoying it, but once I was able to play with it myself, I quickly learned how amazing programming was.<br><br>

My first project was developping a game. In the fifth year of primary school, during the last week of school, our teacher introduced us to the wonderful world of Age of Empires (AoE I to be specific). No wonder my first own game had to be something like Age of Empires: a real time strategy game. I started implementing unit and building classes, resource systems, graphics and an AI (clearly at that time this did not consist of much, but it worked!) I quickly got the support of two class mates and we worked on this project together for a while (adding multiplayer amongst other things). However, due to holiday breaks and, more importantly, at the end of the last year of high school, the change to university, this project fell apart.<br><br>

However, over the years, I often returned to this project. At some point, I tried to salvage the code I could recover from my high school days, but, sadly, this was to no avail. I had to (re)start from scratch. This blog post will cover my latest iteration, which covers a few years (be it with lengthy breaks). When I started learning <tt>Java</tt>, version (1.)7 was in use. At the time of writing, version (1.)24 was the latest one. Many things have changed and many improvements have been added to the language. This means that, after obtaining a PhD in statistics, which implies working with Python for 4 years (and more), I had to relearn a lot and also learned new things along the way. I selected a handful of topics that I want to cover in more detail, give my opinion about their use, and explain some relations to formal mathematics.

[^1]: What a nightmare. It is essentially drawing _UML diagrams_ and learning Java at once, without actually making it easier. I would argue <a href = "https://www.greenfoot.org/door" target = "_blank" rel = "noopener">Greenfoot</a> is better since it adds visual and beginner-oriented tools.

<hr id = "Optionals">
<div class = "nav-block"><div class = "side">Optionals</div></div>

The following practice is common in <tt>Java</tt> code:

<pre><code>
    public void someMethod(ClassA obj) {
        if(obj != null)
            obj.doSomething();
    }
</code></pre>

Although this is very clear from the perspective of readability, it is slightly verbose, increase the amount of brackets that need to be inserted (for longer code blocks), etc. For example, assume that we want to perform a chain of operations. If we want to foolproof the following method call <code>obj.getSomeAttribute().doSomething()</code>,

we would have to write

<pre><code>
    public void someMethod(ClassA obj) {
        if(obj != null &amp;&amp; obj.getSomeAttribute() != null)
            obj.getSomeAttribute().doSomething();
    }
</code></pre>

which requires calling <code class = "language-java">getSomeAttribute()</code> twice, an approach that ought to be avoided in general (especially for costly methods), or

<pre><code>
    public void someMethod(ClassA obj) {
        if(obj != null) {
            ClassB attr = obj.getSomeAttribute();
            if(attr != null)
                attr.doSomething();
        }
    }
</code></pre>

The situation gets even worse if <code>null</code> values need to be handled. This introduces even more braces and control statements. Moreover, without inspection of a method's implementation, it is not clear a priori whether it can return <code>null</code> or not (except when its return type is <code>void</code>). Accordingly, in general, we would need to check for <code>null</code> every time we use a method that is not <code>void</code> or returns a primitive type.<br><br>

To this end, <tt>Java 8</tt> introduced a new (generic) class: <code>Optional&lt;T></code>, which solves both issues at once. When using a method whose return type is of this form, it is immediately clear that the value could correspond to <code>null</code> (of course, it should not exactly be null as this would defeat the whole purpose). The way <code>Optional&lt;T></code> is implemented also allows for easier program flow. The situation considered above will now look as follows:

<pre><code>
    public void someMethod(Optional&lt;SomeClass> obj) {
        obj.ifPresent(ClassA::getSomeAttribute).ifPresent(ClassB::doSomething);
    }
</code></pre>

As in the <code>Stream</code> API, methods can easily be chained. (We will come back to this in a <a href = "#Streams">section</a> further below.) Now, given an instance <code>Optional&lt;T> opt</code>, how do we handle <code>null</code> values? This is covered by the <code>orElse()</code> construction:[^2] The line <code>T result = opt.orElse(alternative);</code> will

* return the instance of class <code>T</code> contained in <code>opt</code> if it is not <code>null</code>, or
* return <code>alternative</code> otherwise.

[^2]: <code>ifPresent(Consumer&lt;? super T> consumer)</code> also admits an alternative <code>ifPresentOrElse(Consumer&lt;? super T> consumer, Runnable alternative)</code> since <tt>Java 9</tt>. 

<hr id = "Monads">
<div class = "nav-block"><div class = "side">Monads</div></div>

<div class = "note">
    <div class = "side">Note</div>
    For people familiar with <tt>Haskell</tt>, this section might be easier. Partially because of the strong relations between functional programming and category theory/type theory, but also because the notion of a monad is baked into <tt>Haskell</tt>.
</div>

In the preceeding section, we saw how we can handle <code>null</code> values in a safe and controlled manner. The only piece that remains is how to instantiate <tt>Java</tt>'s <code>Optional&lt;T></code>s. The most general method to obtain an <code>Optional&lt;T></code> reads as <code>Optional&lt;T> ofNullable(T obj)</code>. If <code>obj == null</code>, it will represent an 'empty' <code>Optional&lt;T></code>. Let us introduce the notations 'Nothing' and 'Just obj', depending on whether <code>obj == null</code> or not.<br><br>

Combined with the functionality presented in the preceeding section, it follows that <tt>Java</tt>'s <code>Optional</code> API gives a common example of a <b>monad</b> (see my previous post on <a href = "{% post_url 2023-05-17-PictorialBayes%}#Monad" target = "_blank">diagrammatic calculus</a> for more information). In particular, it constitutes the <b id = "Maybe">Maybe monad</b>. Formally, it is characterized by the following natural deduction rules:

* <b>Formation</b>: $A:\mathrm{Type}\vdash\mathrm{Maybe}\,A:\mathrm{Type}$,
* <b>Introduction</b>: $a:A\vdash\mathrm{Just}\,a:\mathrm{Maybe}\,A\qquad \mid\qquad \mathrm{Nothing}:\mathrm{Maybe}\,A$,
* <b>Elimination</b>: $o:\mathrm{Maybe}\,A,f:A\rightarrow B\vdash f(o):\mathrm{Maybe}\,B$,
* <b>Computation</b>:
    * $f(\mathrm{Nothing}) \equiv \mathrm{Nothing}$, and
    * $f(\mathrm{Just}\,a) \equiv \mathrm{Just}\,f(a)$.

Let us unpack these rules (in <tt>Java</tt>):
* The formation rule says that,  for every class <code>A</code>, there exists a class <code>Optional&lt;A></code>.
* The introduction rule says that there are two ways to obtain an instance of <code>Optional&lt;A></code>. Either by wrapping an instance of <code>A</code> or the empty <code>Optional&lt;A></code>.
* The elimination rule says that, if we have a method <code>public B f(A obj)</code>, we can map any <code>Optional&lt;A></code> to an <code>Optional&lt;B></code>, i.e. we obtain a method <code>public Optional&lt;B> f(Optional&lt;A> opt)</code>.[^3]
* The implementation of this elimination rule goes as follows:
    * If <code>obj == null</code>, we are working with $\mathrm{Nothing}$, and $\mathrm{Nothing}$ is always mapped to $\mathrm{Nothing}$. Once we start with <code>null</code>, it remains <code>null</code> until the end of time.
    * For nonnull objects, we are working with an instance of the form $\mathrm{Just}\,a$ and applying $f$ is straightforward. $\mathrm{Just}\,a$ is simply a wrapper of $a$, so we can unwrap it, apply $f$ and then wrap it again.

[^3]: Here, and in the preceeding section, I have given in to some abuse of notation. Since the function induced by $f$ is not exactly equal to $f$, it should have been denoted by something like $\mathrm{Maybe}\,f$.

<hr id = "Streams">
<div class = "nav-block"><div class = "side">Streams</div></div>

Above, I referred to the <code>Stream</code> API also introduced in <tt>Java 8</tt>. This API allows to handle <code>Collection</code>s more easily, the most common features being filtering and mapping. Let us start from the beginning and consider a collection like an <code>ArrayList&lt;T></code> (which is just a particular implementation of a sequential list). Now, we would like to apply the method <code>public S transform(T obj)</code> to every element of the list to obtain an instance of <code>ArrayList&lt;T></code>.

The most naive, yet inefficient, approach would be
<pre><code>
    ArrayList&lt;B> listB = new ArrayList<>();
    for(A obj : listA)
        listB.add(transform(A));
</code></pre>

<hr id = "Catamorphisms">
<div class = "nav-block"><div class = "side">Catamorphisms</div></div>

<div class = "note">
    <div class = "side">Note</div>
    This section is of a rather technical nature. If you are not interested in the algebraic foundations of filter methods, I would high recommend to skip the section on a first read-through. There is essentially no computer science to be found down here. &#x1F607;
</div>

As sketched above, the categorical semantics of filtering are not as straightforward as those of function application. However, the underlying structure was too interesting (in my opinion) not to write an additional section on it! Besides the approach through the maybe monad, there is also an approach that makes use of so-called _catamorphisms_.<br><br>

Consider a class $A$, interpreted as a set, and the associated _polynomial functor_ $L_A(X) := 1+A\times X$. It is not hard to convince oneself that $L_A(\mathrm{List}(A))$ is equivalent to $\mathrm{List}(A)$, the unique element $\ast$ being sent to the empty list $[]$. This can be rephrased in the language of $F_A$-algebras. An algebra over an endofunctor $F:\mathbf{C}\rightarrow\mathbf{C}$ is a morphism $F(X)\rightarrow X$ (where $X$ is called the <b id = "Carrier">carrier</b>).[^10] The equivalence $L_A(\mathrm{List}(A))\cong\mathrm{List}(A)$ is then a consequence of <a href = "https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem" target = "_blank">Lambek's theorem</a>, since $\mathrm{List}(A)$ is the initial algebra for $F_A$. So let us first see what $F$-algebra morphisms are.<br><br>

A morphism $\varphi:(A,\alpha_A)\rightarrow(B,\alpha_B)$ of $F$-algebras is a commutative square as shown below.

<picture>
    <img src = "{{site.baseurl}}/assets/figures/FAlgebra.svg" style = "width: 30%">
</picture>

The algebra $(A,\alpha_A)$ is said to be **initial** if there exists a unique such diagram for every other algebra $(B,\alpha_B)$. Lambek's theorem then says that $\alpha_A$ is an isomorphism whenever it is initial. Now, since $\alpha_A$ is an iso, it has an inverse $\alpha^{-1}_A$ which makes the following diagram commute.

<picture>
    <img src = "{{site.baseurl}}/assets/figures/FAlgebra2.svg" style = "width: 30%">
</picture>

It follows that the algebra morphism admits the following recursive expression:

\begin{gather}
    \label{cata}
    \varphi = \alpha_B\circ F(\varphi)\circ \alpha^{-1}_A\,.
\end{gather}

Such morphisms out of an initial algebra are also called <b id = "Catamorphism">catamorphisms</b>. Now, we can return to how filtering of lists with respect to a given predicate can be incorporated. Every predicate $p:A\rightarrow\mathbf{2}$ gives rise to an $F_A$-algebra structure on $\mathrm{List}(A)$ as follows:

$$
    \pi_p:
    \begin{cases}
        \ast\mapsto []&\\
        (a_0,[a_1,\ldots,a_n])\mapsto[a_0,a_1,\ldots,a_n]&\text{ if }p(a_0)\\
        (a_0,[a_1,\ldots,a_n])\mapsto[a_1,\ldots,a_n]&\text{ otherwise}
    \end{cases}
$$

The catamorphism associated to $\pi_p$ can be (recursively) obtained through Eq. \eqref{cata}. The first step is to see how it acts on the empty list (try to have a guess before you read on).

<div class = "spoiler">
<div markdown = "1" class = "content">
\begin{align\*}
    \varphi([]) &= \pi_p\circ F_A(\varphi)\circ\alpha^{-1}_{\mathrm{List}(A)}([])\\\\\\
    &= \pi_p\circ F_A(\varphi)(\ast)\\\\\\
    &= \pi_p(\ast)\\\\\\
    &= []
\end{align\*}
</div>
</div>

Now, what about a singleton list?

\begin{align\*}
    \varphi([a]) &= \pi_p\circ F_A(\varphi)\circ\alpha^{-1}_{\mathrm{List}(A)}([a])\\\\\\
    &= \pi_p\circ F_A(\varphi)(a,[])\\\\\\
    &= \pi_p(a,[])\\\\\\
    &= \begin{cases}
            [a]&\text{ if }p(a)\\\\\\
            []&\\text{ otherwise}
        \end{cases}
\end{align\*}

[^10]: Algebras over an endofunctor can be seen as a generalization of representations in group theory.


<hr id = "References">
<div class = "nav-block"><div class = "side">References</div></div>

* <a href = "https://learnyouahaskell.github.io/" target = "_blank">https://learnyouahaskell.github.io/</a><br><br>
* <a href = "https://bartoszmilewski.com/2017/02/28/f-algebras/" target = "_blank">https://bartoszmilewski.com/2017/02/28/f-algebras/</a><br>
(Bartosz' site is an absolute goldmine for everything related to computer science and category theory.)<br><br>
* Awodey, S. (2010). _Category theory_. OUP Oxford.

<hr id = "Footnotes">
<div class = "nav-block"><div class = "side">Footnotes</div></div>

